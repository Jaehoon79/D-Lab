<출처> http://www.ibm.com/developerworks/kr/library/l-gas-nasm.html

 서론

다른 언어와는 달리, 어셈블리 프로그래밍은 프로그램 대상 기계가 채용한 프로세서 아키텍처를 이해해야 한다. 어셈블리 프로그램은 이식성이 없으며, 종종 유지와 이해보수도 성가시며, 코드 행이 무척 길다. 하지만 대상 기계에서 수행하는 실행 바이너리 속력과 크기라는 우월성 덕분에 이런 제약을 극복할 수 있다.

이미 리눅스에서 어셈블리 수준 프로그래밍에 대해 많은 정보가 나와 있음에도 불구하고, 이 기사는 특정 어셈블리를 다른 어셈블리로 쉽게 변환하도록 돕기 위해 구문 사이에 존재하는 차이점을 좀더 구체적으로 소개한다. 이 기사는 변환 과정을 개선하기 위해 직접 겪었던 경험을 토대로 작성했다.

이 기사는 몇 가지 프로그램 예제를 사용한다. 구문 토론과 비교에 이어 주요 기능 설명을 위해 각 프로그램을 예로 든다. NASM과 GAS 사이에 나타나는 모든 차이점을 다루기란 불가능하지만 핵심을 빠뜨리지 않으려고 노력했으며, 향후 추가 검토 과정에 필요한 기반 지식을 제공한다. 이미 NASM과 GAS에 익숙한 개발자를 위해 매크로와 같은 몇몇 유용한 구성요소도 설명한다.

이 기사는 개발자가 어셈블리 용어를 기본적으로 이해하고 있으며, 리눅스나 윈도우 환경에서 NASM과 같은 인텔(Intel®) 구문을 따르는 어셈블러로 프로그래밍을 경험해 봤다고 가정한다. 이 기사는 편집기를 사용하는 방법이나 어셈블과 링크 방법을 다루지 않는다(기억을 되살리려면 '예제 빌드하기' 항목을 살펴보라). 기본적으로 (레드햇이나 슬랙웨어와 같은 배포판에 무관한) 리눅스 운영체제와 gcc와 ld 같은 기본 GNU 도구에 익숙해야 하며, x86 기계에서 프로그램을 만들어본 경험이 있어야 한다.

이제 이 기사에서 다루는 것과 다루지 않는 것을 설명하겠다.

예제 빌드하기

어셈블: 
GAS:
as -o program.o program.s 

NASM:
nasm -f elf -o program.o program.asm 

링크(양쪽 어셈블러에 동일하다): 
ld -o program program.o 

외부 C 라이브러리를 사용할 경우 다음과 같이 링크한다: 
ld --dynamic-linker /lib/ld-linux.so.2 -lc -o program program.o 

이번 기사는 다음 내용을 다룬다.

NASM과 GAS 사이에 존재하는 기본적인 구문 차이점 
변수, 루프, 라벨, 매크로와 같은 공통 어셈블리 구성요소 
외부 C 루틴을 호출하고 함수를 사용하는 방법 
어셈블리 니모닉 차이점과 활용법 
메모리 주소 지정 방법 
이번 기사는 다음 내용을 다루지 않는다.

프로세서 명령어 집합 
어셈블러에 밀접한 다양한 매크로와 다른 구성요소 
NASM이나 GAS에 밀접한 어셈블러 지시자 
특정 어셈블러에만 존재하는, 일반적으로 쓰이지 않는 기능 
정보가 더 필요하다면 완벽한 정보를 담고 있는 공식 어셈블러 매뉴얼을 참조하자(참고자료를 살펴보기 바란다).


--------------------------------------------------------------------------------

위로

기본 구조

Listing 1은 종료 결과값으로 단순히 2를 반환하는 아주 간단한 프로그램을 보여준다. 이 짧은 프로그램은 GAS와 NASM을 위한 어셈블리 프로그램의 기본 구조를 기술한다.

Listing 1. 종료 결과값으로 2를 반환하며 종료하는 프로그램  행 NASM GAS 
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016

 

 ; 텍스트 세그먼트 시작
section .text

   global _start

; 프로그램 진입점
   _start:

; 시스템 호출을 위한 코드 번호 지정
      mov   eax, 1 

; 반환값
      mov   ebx, 2

; 운영체제 호출
      int   80h

 

 # 텍스트 세그먼트 시작
.section .text

   .globl _start

# 프로그램 진입점
   _start:

# 시스템 호출을 위한 코드 번호 지정
      movl  $1, %eax

/* 반환값 */
      movl  $2, %ebx

# 운영체제 호출
      int   $0x80

 

 


설명을 좀더 진행해보자.

NASM과 GAS 사이에 존재하는 가장 큰 차이점은 구문이다. GAS는 GAS나 몇몇 옛날 어셈블러에 밀접한 비교적 고풍스러운 구문인 AT&T 구문을 사용하는 반면 NASM은 TASM이나 MASM과 같은 대다수 어셈블러가 지원하는 인텔 구문을 사용한다. (근래 나온 GAS 버전은 .intel_syntax라는 지시자를 지원해서 GAS로 인텔 구문을 사용하도록 허용한다.)

GAS 매뉴얼에 요약된 주요 차이점 몇 가지를 정리했다.

AT&T와 인텔 구문은 출발지와 목적지 피연산자를 반대로 사용한다. 예를 들면 다음과 같다. 
인텔: mov eax, 4 
AT&T: movl $4, %eax 
AT&T 구문에서 직접 피연산자는 $로 시작한다. 인텔 구문에서는 피연산자에 $가 직접 붙지 않는다. 예를 들면 다음과 같다. 
인텔: push 4 
AT&T: pushl $4 
AT&T 구문에서 레지스터 피연산자는 %로 시작한다. 인텔 구문에서는 레지스터 피연산자에 %가 붙지 않는다. 
AT&T 구문에서 메모리 피연산자 크기는 옵코드 이름의 마지막 글자로 결정한다. 옵코드는 b(8비트), w(16비트), l(32비트)로 각각 정해진 메모리 참조를 나타낸다. 인텔 구문은 (옵코드 자체가 아니라) byte ptr, word ptr, dword ptr과 같은 메모리 피연산자 접두어로 결정한다. 다음 예를 살펴보자. 
인텔: mov al, byte ptr foo 
AT&T: movb foo, %al 
long jump나 call과 같은 직접 형식은 AT&T 구문에서 lcall/ljmp $section, $offset이며, 인텔 구문에서 call/jmp far section:offset이다. far return 명령은 AT&T 구문에서 lret $stack-adjust이며, 인텔 구문에서 ret far stack-adjust다. 
양쪽 어셈블러에서 레지스터 이름은 동일하지만 주소 지정 모드에서 구문이 조금 다르다. 추가적으로 GAS에서 어셈블러 지시자는 "."으로 시작하지만 NASM에서는 그렇지 않다.

.text 섹션은 프로세서가 코드를 시작하는 위치다. global(GAS에서는 .globl이나 .global) 키워드는 심볼을 링커에 공개하거나 다른 목적 파일에 공개하기 위해 쓰인다. Listing 1에서 NASM 쪽을 보면 global_start는 링커에게 프로그램으로 건너뛰어 실행할 위치를 지정하도록 _start라는 심볼을 공개 식별자로 표시한다. NASM과 마찬가지 GAS는 _start 라벨을 찾아서 프로그램 기본 시작 위치로 삼는다. GAS나 NASM 모두 라벨이 콜론(:)으로 끝난다.

인터럽트는 서비스가 필요하다고 운영체제에 알려주는 방법이다. 16행에 나오는 int 명령이 우리 프로그램에서 이런 작업을 담당한다. GAS나 NASM 모두 인터럽트로 동일한 니모닉을 사용한다. GAS는 16진수를 표시하기 위해 0x라는 접두사를 사용하며, NASM은 h라는 접미사를 사용한다. GAS에서 피연산자에 직접 접두사 $를 붙이므로 16진수 80은 $0x80이 된다.

int $0x80(또는 NASM에서 80h)는 리눅스에 서비스를 요청하기 위해 사용한다. 서비스 코드는 EAX 레지스터에 존재한다. (리눅스 exit 시스템 호출을 위한) 1이라는 값을 EAX에 저장해 프로그램 종료를 요청한다. 레지스터 EBX는 프로그램 종료 코드(여기서는 2)를 저장해 운영체제에 반환할 값을 지정한다. (명령행으로 echo $?를 입력하면 이 값을 추적할 수 있다.)

마지막으로 주석에 대해 언급하겠다. GAS는 C 스타일(/* */)과 C++ 스타일(//), 셸 스타일(#) 주석을 모두 지원한다. NASM은 ";" 글자로 시작하는 단일 행 주석을 지원한다.


--------------------------------------------------------------------------------

위로

변수와 메모리 접근

이 절은 숫자 세 개 중 최대값을 찾는 예제 프로그램으로 시작하겠다.

Listing 2. 숫자 세 개 중 최대값을 찾는 프로그램  행 NASM GAS 
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016
017
018
019
020
021
022
023
024
025
026
027
028
029
030
031

 

 ; 자료 섹션 시작
section .data

   var1 dd 40

   var2 dd 20

   var3 dd 30


section .text

   global _start

   _start:

; 변수 값 이동
      mov   ecx, [var1]
      cmp   ecx, [var2]
      jg    check_third_var
      mov   ecx, [var2]

   check_third_var:
      cmp   ecx, [var3]
      jg    _exit
      mov   ecx, [var3]

   _exit:
      mov   eax, 1
      mov   ebx, ecx
      int   80h

 

 // 자료 섹션 시작
.section .data
   
   var1:
      .int 40
   var2:
      .int 20
   var3:
      .int 30

.section .text

   .globl _start

   _start:

# 변수 값 이동
      movl  (var1), %ecx
      cmpl  (var2), %ecx
      jg    check_third_var
      movl  (var2), %ecx

   check_third_var:
      cmpl  (var3), %ecx
      jg    _exit
      movl  (var3), %ecx
   
   _exit:
      movl  $1, %eax
      movl  %ecx, %ebx
      int   $0x80

 

 


메모리 변수 선언에서 여러 가지 차이점을 발견할 수 있다. NASM은 32, 16, 8비트 숫자를 선언하기 위해 각각 dd, dw, db 지시자를 사용하는 반면, GAS는 각각 .long, .int, .byte를 사용한다. GAS에는 .ascii, asciz, .string과 같은 다른 지시자도 있다. GAS에서는 (콜론을 사용해) 다른 라벨처럼 변수를 선언하지만, NASM에서는 단순히 (콜론 없이) 변수 이름만을 입력하고 메모리 할당 지시자(dd, dw 등)를 붙이고 변수 값을 지정하면 된다.

Listing 2에서 18행은 메모리 간접 주소 지정 모드를 보여준다. NASM은 메모리 위치를 지정하는 포인터 주소 값을 역참조하기 위해 [var1]과 같이 대괄호를 사용한다. GAS는 동일한 값을 역참조하기 위해 (var1)과 같이 소괄호를 사용한다. 다른 주소 지정 모드는 이 기사 후반에 다룬다.


--------------------------------------------------------------------------------

위로

매크로 활용하기

Listing 3은 이 절에서 소개할 사용자 이름을 입력받아 인사말을 돌려주는 프로그램이다.

Listing 3. 문자열을 읽어 사용자에게 인사말을 출력하는 프로그램  행 NASM GAS 
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016
017
018
019
020
021
022
023
024
025
026
027
028
029
030
031
032
033
034
035
036
037
038
039
040
041
042
043
044
045
046
047
048
049
050
051
052
053
054
055
056
057
058
059
060
061
062

 

 section .data

   prompt_str  db   'Enter your name: '

; $는 위치 카운터
   STR_SIZE  equ  $ - prompt_str

   greet_str  db  'Hello '


   GSTR_SIZE  equ  $ - greet_str


section .bss

; 메모리에서 32바이트 할당
   buff  resb  32

; 매개변수 두 개를 지정하는 매크로
; write 시스템 호출 구현
   %macro write 2 
      mov   eax, 4
      mov   ebx, 1
      mov   ecx, %1
      mov   edx, %2
      int   80h
   %endmacro


; read 시스템 호출 구현
   %macro read 2
      mov   eax, 3
      mov   ebx, 0
      mov   ecx, %1
      mov   edx, %2
      int   80h
   %endmacro


section .text

   global _start

   _start:
      write prompt_str, STR_SIZE
      read  buff, 32

; eax에 넘어온 길이를 넣는다.
      push  eax

; 인사말 출력
      write greet_str, GSTR_SIZE

      pop   edx

; edx  = read가 반환한 길이
      write buff, edx

   _exit:
      mov   eax, 1
      mov   ebx, 0
      int   80h

 

 .section .data

   prompt_str:
      .ascii "Enter Your Name: "
   pstr_end:
      .set STR_SIZE, pstr_end - prompt_str

   greet_str:
      .ascii "Hello "

   gstr_end:
      .set GSTR_SIZE, gstr_end - greet_str

.section .bss

// 메모리에서 32바이트 할당
   .lcomm  buff, 32

// 매개변수 두 개를 지정하는 매크로
// write 시스템 호출 구현
   .macro write str, str_size 
      movl  $4, %eax
      movl  $1, %ebx
      movl  \str, %ecx
      movl  \str_size, %edx
      int   $0x80
   .endm


// read 시스템 호출 구현
   .macro read buff, buff_size
      movl  $3, %eax
      movl  $0, %ebx
      movl  \buff, %ecx
      movl  \buff_size, %edx
      int   $0x80
   .endm


.section .text

   .globl _start

   _start:
      write $prompt_str, $STR_SIZE
      read  $buff, $32

// eax에 넘어온 길이를 넣는다.
      pushl %eax

// 인사말 출력
      write $greet_str, $GSTR_SIZE

      popl  %edx

// edx  = read가 반환한 길이
   write $buff, %edx

   _exit:
      movl  $1, %eax
      movl  $0, %ebx
      int   $0x80

 

 


앞서 NASM과 GAS를 모두 지원하는 매크로를 다루겠다고 약속했다. 하지만 매크로 탐구에 나서기 전에 비교할 만한 몇 가지 기능을 짚고 넘어가겠다.

Listing 3은 초기화하지 않은 메모리 개념을 소개하는데, 초기화하지 않은 메모리 영역은 (14행에 나오는) .bss 섹션 지시자를 사용해 정의한다. BSS는 "block storage segment"를 줄인 말이며(원래는 "block started by symbol"이었다), BSS 섹션에 확보된 메모리는 프로그램 시작 과정에서 0으로 초기화된다. BSS 섹션에 있는 객체는 이름과 크기만 있으며 값은 없다. BSS 섹션에 선언된 변수는 데이터 세그멘트와는 달리 실제로 공간을 차지하지 않는다.

NASM은 바이트, 워드, 더블워드 공간을 BSS 섹션에 할당하기 위해 각각 resb, resw, resd 키워드를 사용한다. 반면에 GAS는 바이트 단위 공간 할당을 위해 .lcomm 키워드를 사용한다. 양쪽 프로그램에서 변수 이름을 선언하는 방식에 주목하자. NASM에서 변수 이름은 resb(resw, resd) 키워드와 할당할 공간 크기 앞에 위치하는 반면에, GAS에서는 변수 이름이 .lcomm 키워드 뒤에 위치하며, 쉼표에 이어 할당할 공간 크기가 이어진다. 차이점을 요약하면 다음과 같다.

NASM: 변수이름 resb 크기 

GAS: .lcomm 변수이름, 크기 

Listing 2는 또한 위치 카운터(6행) 개념을 소개한다. NASM은 특별한 변수($와 $$ 변수)를 제공해 위치 카운터를 처리한다. GAS에서는 위치 카운터를 조작하는 방법이 없으며, (자료, 명령 등) 다음 저장 위치를 계산하기 위해 라벨을 사용해야만 한다.

예를 들어, 문자열 길이를 계산하기 위해 NASM에서는 다음과 같은 관용구를 사용한다.

prompt_str db 'Enter your name: '
STR_SIZE equ $ - prompt_str     ; $는 위치 카운터 

$는 위치 카운터의 현재 값을 돌려주며, 위치 카운터에서 라벨(모든 변수 이름은 라벨이다) 값을 빼면 라벨 선언부터 현재 위치까지 거리를 바이트 단위로 구할 수 있다. equ 지시자는 변수 STR_SIZE 값을 따라오는 표현식 값으로 설정하는 데 사용한다. 비슷한 GAS 관용구는 다음과 같다.

prompt_str:
     .ascii "Enter Your Name: "

pstr_end:
     .set STR_SIZE, pstr_end - prompt_str 

종료 라벨(pstr_end)은 다음 위치 주소를 가리키며, 종료 라벨에서 시작 라벨을 빼면 크기가 나온다. .set를 사용해 STR_SIZE 값을 쉼표로 따라오는 표현식에 대입하는 용법에 주목하자. .equ 또한 사용할 수 있다. GAS의 set 지시자에 대응하는 지시자가 NASM에는 없다.

이미 언급한 바와 같이 Listing 3은 매크로를 사용한다(21행). 단일 행 매크로와 매크로 중복을 비롯해 NASM과 GAS에서 사용하는 매크로에는 차이점이 있는데, 여기서는 기본 유형만 다룬다. 어셈블러에서 매크로를 활용하는 이유는 명쾌함 때문이다. 동일한 코드 조각을 두고 두고 반복해 입력하는 대신, 이런 중복을 피하고 잔가지를 쳐냄으로써 코드 가독성을 높이고 보기 좋게 만들기 위해 재사용 가능한 매크로를 정의할 수 있다.

NASM 사용자라면 %beginmacro 지시자로 시작해 %endmacro 지시자로 끝나는 매크로 선언 방법에 익숙할지도 모르겠다. %beginmacro 지시자 다음에는 매크로 이름이 따라온다. 매크로 이름 뒤에는 매크로가 기대하는 매개변수 숫자가 따라온다. NASM에서 매크로 매개변수는 1로 시작하며 순차적으로 증가한다. 다시 말해 첫 번째 매크로는 %1, 두 번째 매크로는 %2, 세 번째 매크로는 %3 등이다. 예는 다음과 같다.

%beginmacro macroname 2
     mov eax, %1
     mov ebx, %2
%endmacro 

이 예제는 매개변수 둘로 매크로를 만드는데, 첫 번째 매개변수가 %1, 두 번째 매개변수가 %2가 된다. 따라서 위에서 정의한 매크로 호출 예는 다음과 같다.

macroname 5, 6 

매크로는 또한 매개변수 없이 만들 수 있는데, 이 경우 숫자를 지정하지 않으면 된다.

이제 GAS가 매크로를 사용하는 방법을 살펴볼 차례다. GAS는 .macro와 .endm 지시자를 사용해 매크로를 생성한다. .macro 지시자 뒤에 매크로 이름이 따라오며 매개변수를 붙일 수도 있다. GAS에서 매크로 매개변수는 이름으로 지정한다. 예는 다음과 같다.

.macro macroname arg1, arg2
     movl \arg1, %eax
     movl \arg2, %ebx
.endm 

실제 매크로 내부에서 쓰일 각 매크로 인수 이름 앞에 역슬래시가 붙는다. 역슬래시를 빼버리면, 링커가 이름을 인수가 아니라 라벨로 취급하므로 오류가 발생한다.


--------------------------------------------------------------------------------

위로

함수, 외부 루틴, 스택

이번 절에서 다룰 예제 프로그램은 정수 배열을 선택 정렬하는 구현 방법을 다룬다.

Listing 4. 정수 배열을 선택 정렬하는 구현 방법y  행 NASM GAS 
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016
017
018
019
020
021
022
023
024
025
026
027
028
029
030
031
032
033
034
035
036
037
038
039
040
041
042
043
044
045
046
047
048
049
050
051
052
053
054
055
056
057
058
059
060
061
062
063
064
065
066
067
068
069
070
071
072
073
074
075
076
077
078
079
080
081
082
083
084
085
086
087
088
089
090
091
092
093
094
095
096
097
098
099
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145

 

 section .data

   array db
      89, 10, 67, 1, 4, 27, 12, 34,
         86, 3

   ARRAY_SIZE equ $ - array


   array_fmt db "  %d", 0


   usort_str db "unsorted array:", 0


   sort_str db "sorted array:", 0


   newline db 10, 0



section .text
   extern puts

   global _start

   _start:

      push  usort_str
      call  puts
      add   esp, 4
   
      push  ARRAY_SIZE
      push  array
      push  array_fmt
      call  print_array10
      add   esp, 12

      push  ARRAY_SIZE 
      push  array
      call  sort_routine20

; 스택 포인터 조정
      add   esp, 8

      push  sort_str
      call  puts
      add   esp, 4

      push  ARRAY_SIZE 
      push  array
      push  array_fmt
      call  print_array10
      add   esp, 12
      jmp   _exit

      extern printf

   print_array10:
      push  ebp
      mov   ebp, esp
      sub   esp, 4
      mov   edx, [ebp + 8]
      mov   ebx, [ebp + 12]
      mov   ecx, [ebp + 16]

      mov   esi, 0

   push_loop:
      mov   [ebp - 4], ecx
      mov   edx, [ebp + 8]
      xor   eax, eax
      mov   al, byte [ebx + esi]
      push  eax
      push  edx

      call  printf
      add   esp, 8
      mov   ecx, [ebp - 4]
      inc   esi
      loop  push_loop

      push  newline
      call  printf
      add   esp, 4
      mov   esp, ebp
      pop   ebp
      ret

   sort_routine20:
      push  ebp
      mov   ebp, esp

; 스택에서 워드 공간 할당
      sub   esp, 4 

; 배열 주소 확보
      mov   ebx, [ebp + 8] 

; 배열 크기 저장
      mov   ecx, [ebp + 12]
      dec   ecx

; 여기서 외부 루프 준비
      xor   esi, esi

   outer_loop:
; min 색인 저장
      mov   [ebp - 4], esi 
      mov   edi, esi
      inc   edi

   inner_loop:
      cmp   edi, ARRAY_SIZE
      jge   swap_vars
      xor   al, al
      mov   edx, [ebp - 4]
      mov   al, byte [ebx + edx]
      cmp   byte [ebx + edi], al
      jge   check_next
      mov   [ebp - 4], edi

   check_next:
      inc   edi
      jmp   inner_loop

   swap_vars:
      mov   edi, [ebp - 4]
      mov   dl, byte [ebx + edi]
      mov   al, byte [ebx + esi]
      mov   byte [ebx + esi], dl
      mov   byte [ebx + edi], al

      inc   esi
      loop  outer_loop

      mov   esp, ebp
      pop   ebp
      ret

   _exit:
      mov   eax, 1
      mov   ebx, 0
      int   80h

 

 .section .data

   array:
      .byte  89, 10, 67, 1, 4, 27, 12,
             34, 86, 3

   array_end:
      .equ ARRAY_SIZE, array_end - array

   array_fmt:
      .asciz "  %d"

   usort_str:
      .asciz "unsorted array:"

   sort_str:
      .asciz "sorted array:"

   newline:
      .asciz "\n"


.section .text


   .globl _start

   _start:

      pushl $usort_str
      call  puts
      addl  $4, %esp

      pushl $ARRAY_SIZE
      pushl $array
      pushl $array_fmt
      call  print_array10
      addl  $12, %esp

      pushl $ARRAY_SIZE
      pushl $array
      call  sort_routine20

# 스택 포인터 조정
      addl  $8, %esp

      pushl $sort_str
      call  puts
      addl  $4, %esp

      pushl $ARRAY_SIZE
      pushl $array
      pushl $array_fmt
      call  print_array10
      addl  $12, %esp
      jmp   _exit



   print_array10:
      pushl %ebp
      movl  %esp, %ebp
      subl  $4, %esp
      movl  8(%ebp), %edx
      movl  12(%ebp), %ebx
      movl  16(%ebp), %ecx

      movl  $0, %esi

   push_loop:
      movl  %ecx, -4(%ebp)  
      movl  8(%ebp), %edx
      xorl  %eax, %eax
      movb  (%ebx, %esi, 1), %al
      pushl %eax
      pushl %edx

      call  printf
      addl  $8, %esp
      movl  -4(%ebp), %ecx
      incl  %esi
      loop  push_loop

      pushl $newline
      call  printf
      addl  $4, %esp
      movl  %ebp, %esp
      popl  %ebp
      ret

   sort_routine20:
      pushl %ebp
      movl  %esp, %ebp

# 스택에서 워드 공간 할당
      subl  $4, %esp

# 배열 주소 확보
      movl  8(%ebp), %ebx

# 배열 크기 저장
      movl  12(%ebp), %ecx
      decl  %ecx

# 여기서 외부 루프 준비
      xorl  %esi, %esi

   outer_loop:
# 여기서 min 색인 저장
      movl  %esi, -4(%ebp)
      movl  %esi, %edi
      incl  %edi

   inner_loop:
      cmpl  $ARRAY_SIZE, %edi
      jge   swap_vars
      xorb  %al, %al
      movl  -4(%ebp), %edx
      movb  (%ebx, %edx, 1), %al
      cmpb  %al, (%ebx, %edi, 1)
      jge   check_next
      movl  %edi, -4(%ebp)

   check_next:
      incl  %edi
      jmp   inner_loop

   swap_vars:
      movl  -4(%ebp), %edi
      movb  (%ebx, %edi, 1), %dl
      movb  (%ebx, %esi, 1), %al
      movb  %dl, (%ebx, %esi, 1)
      movb  %al, (%ebx,  %edi, 1)

      incl  %esi
      loop  outer_loop

      movl  %ebp, %esp
      popl  %ebp
      ret

   _exit:
      movl  $1, %eax
      movl  0, %ebx
      int   $0x80

 

 


Listing 4는 처음에는 아주 복잡해 보이지만, 실제로는 아주 단순하다. 목록은 함수 개념, 다양한 메모리 주소 지정 방식, 스택, 라이브러리 함수 활용법을 다룬다. 이 프로그램은 숫자 10개가 담긴 배열을 정렬하고 정렬되지 않은 배열과 정렬된 배열 전체 내용을 외부 C 라이브러리 함수인 puts와 printf를 사용해 출력한다. 모듈화와 함수 개념을 설명하기 위해, 정렬 루틴 자체는 배열 인쇄 루틴과 함께 독자적인 프로시저로 구현되었다. 하나씩 살펴보자.

자료 선언 직후 프로그램 실행은 puts 호출부터 시작한다(31행). puts 함수는 콘솔로 문자열을 출력한다. 유일한 인수는 출력될 문자열 주소이며, 스택에 문자열 주소를 밀어넣는 방법으로 인수를 전달한다(30행).

NASM에서 프로그램의 일부가 아니기 때문에 링크 시점에 결정되어야 할 라벨은 extern 키워드로 함수를 반드시 미리 정의해 놓아야 한다(24행). GAS에는 이런 제약 사항이 없다. 콘솔 출력 다음으로 usort_str 문자열 주소를 스택에 밀어넣는다(30행). NASM에서 usort_str과 같은 메모리 변수는 메모리 위치 주소 자체를 나타내므로 push usort_str과 같은 호출은 실제로 스택 상단에 주소를 밀어넣는다. 반면에 GAS에서는 변수 usort_str에 $ 접두어를 반드시 붙여서 직접 주소로 취급하도록 만들어야 한다. $ 접두어가 없다면, 메모리 주소가 아니라 메모리 변수가 표현하는 실제 바이트를 스택에 밀어넣는다.

변수를 스택에 밀어넣으면 스택 포인터가 dword만큼 움직여야 하므로, 스택 포인터에 (dword 크기인) 4를 더해서 조정해야 한다(32행).

스택에 인수 셋을 밀어넣었고 print_array10을 호출한다(37행). 함수는 NASM이나 GAS에서 동일한 방식으로 선언한다. call 명령을 사용하려면 라벨을 제외한 다른 부수적인 구성요소는 필요없다.

함수 호출 다음에 ESP는 스택 최상단을 나타낸다. esp + 4 값은 반환 주소를 나타내고, esp + 8 값은 함수에 넘기는 첫 인수를 나타낸다. 이어지는 인수는 스택 포인터에 dword 변수 크기를 더하는 방법으로 접근이 가능하다(즉 esp + 12, esp + 16 등).

일단 함수 내부로 들어가면, esp를 ebp로 복사해 지역 스택 프레임을 생성한다(62행). 또한 프로그램에서 지역 변수를 위한 공간을 확보한다(63행). esp에서 필요한 바이트 숫자만큼 빼는 방법으로 지역 변수 공간을 확보할 수 있다. esp - 4 값은 지역 변수를 위한 4바이트 할당을 나타내며, 지역 변수를 수용하기 위해 스택에 충분한 공간이 있다면 필요한만큼 늘일 수 있다.

Listing 4는 기본 간접 주소 지정 모드를 예시하는데(64행), 기본 주소로 시작해 마지막 주소에 이르기까지 변위를 더하기 때문에 이런 이름이 붙었다. NASM 쪽을 보면 [ebp + 8]과 [ebp - 4]처럼 표현한다. GAS 쪽을 보면 주소 지정은 좀더 간결해서 각각 8(%ebp)와 -4(%ebp)처럼 표현한다.

print_array10 루틴에서 push_loop 라벨(74행) 다음에 사용된 또 다른 주소 지정 모드를 볼 수 있다. NASM과 GAS에서 각각 다음과 같은 행이 보일 것이다.

NASM: mov al, byte [ebx + esi] 

GAS: movb (%ebx, %esi, 1), %al 

이런 방식은 기본 색인 주소 지정 모드다. 여기서 구성요소가 세 개 등장한다. 첫째는 기본 주소, 둘째는 색인 레지스터, 셋째는 승수(乘數)다. 메모리 위치에서 접근하는 바이트 숫자를 결정하기란 불가능하므로 주소를 지정한 메모리 총량을 찾아내기 위한 방법이 필요하다. NASM은 byte 연산자를 사용해 자료에서 한 바이트가 이동했음을 어셈블러에 알려준다. GAS에서는 니모닉에 b, w, l 접미사를 붙이는(예를 들어, movb) 동시에 승수를 사용해 이런 문제를 해결한다. 처음 보면 GAS 구문이 좀더 복잡해보일 수도 있다.

GAS에서 일반적인 기본 색인 주소 지정 형식은 다음과 같다.

%segment:ADDRESS (, index, multiplier) 

또는 

%segment:(offset, index, multiplier) 

또는 

%segment:ADDRESS(base, index, multiplier) 

이 공식을 사용해 최종 주소를 계산한다.

ADDRESS or offset + base + index * multiplier. 

따라서 바이트에 접근하려면 승수는 1이 되며, 워드에 접근하려면 승수는 2가 되며, 더블 워드에 접근하려면 승수가 4가 되어야 한다. 물론 NASM은 좀더 단순한 구문을 사용한다. 따라서 NASM으로 상기 공식을 풀어쓰면 다음과 같다.

Segment:[ADDRESS or offset + index * multiplier] 

각각 메모리 1, 2, 4 바이트에 접근하도록 byte, word, dword 접두사를 메모리 주소 앞에 표시한다.


--------------------------------------------------------------------------------

위로

나머지 이야기

Listing 5는 명령행 인수 목록을 읽어 메모리에 저장하고 출력한다.

Listing 5. 명령행 인수 목록을 읽어 메모리에 저장하고 출력하는 프로그램  행 NASM GAS 
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016
017
018
019
020
021
022
023
024
025
026
027
028
029
030
031
032
033
034
035
036
037
038
039
040
041
042
043
044
045
046
047
048
049
050
051
052
053
054
055
056
057
058
059
060
061

 

 section .data

; 최대 10개 명령행 인수를 저장할 명령어 테이블
   cmd_tbl:
      %rep 10
         dd 0
      %endrep

section .text

   global _start

   _start:
; 스택 프레임 설정
      mov   ebp, esp
; 스택 최상단은 명령행 인수 숫자를 포함
; 기본값은 1
      mov   ecx, [ebp]

; 인수가 10개를 넘으면 종료
      cmp   ecx, 10
      jg    _exit

      mov   esi, 1
      mov   edi, 0

; 명령어 테이블에 명령행 인수 저장
   store_loop:
      mov   eax, [ebp + esi * 4]
      mov   [cmd_tbl + edi * 4], eax
      inc   esi
      inc   edi
      loop  store_loop

      mov   ecx, edi
      mov   esi, 0

      extern puts
   
   print_loop:
; 몇몇 지역 공간 확보
      sub   esp, 4
; puts 함수는 ecx를 망가뜨린다.
      mov   [ebp - 4], ecx
      mov   eax, [cmd_tbl + esi * 4]
      push  eax
      call  puts
      add   esp, 4
      mov   ecx, [ebp - 4]
      inc   esi
      loop  print_loop

      jmp   _exit
   
   _exit:
      mov   eax, 1
      mov   ebx, 0
      int   80h

 

 .section .data

// 최대 10개 명령행 인수를 저장할 명령어 테이블
   cmd_tbl:
      .rept 10
         .long 0
      .endr

.section .text

   .globl _start

   _start:
// 스택 프레임 설정
      movl  %esp, %ebp
// 스택 최상단은 명령행 인수 숫자를 포함
// 기본값은 1
      movl  (%ebp), %ecx

// 인수가 10개를 넘으면 종료
      cmpl  $10, %ecx
      jg    _exit
   
      movl  $1, %esi
      movl  $0, %edi

// 명령어 테이블에 명령행 인수 저장
   store_loop:
      movl  (%ebp, %esi, 4), %eax
      movl  %eax, cmd_tbl( , %edi, 4)
      incl  %esi
      incl  %edi
      loop  store_loop

      movl  %edi, %ecx
      movl  $0, %esi



   print_loop:
// 몇몇 지역 공간 확보
      subl  $4, %esp
// puts 함수는 ecx를 망가뜨린다.
      movl  %ecx, -4(%ebp)
      movl  cmd_tbl( , %esi, 4), %eax
      pushl %eax
      call  puts
      addl  $4, %esp
      movl  -4(%ebp), %ecx
      incl  %esi
      loop  print_loop

      jmp   _exit

   _exit:
      movl  $1, %eax
      movl  $0, %ebx
      int   $0x80

 

 


Listing 5는 어셈블리로 명령을 반복하는 구성요소를 보여준다. 지극히 당연하게도 이는 반복 구성요소라 부른다. GAS에서 반복 구성요소는 .rept 지지자(6행)를 사용해 시작한다. 이 지시자는 .endr 지시자(8행)를 사용해 끝을 맺어야 한다. GAS에서 .rept 뒤에 .rept/.endr 구성요소 내부에 들어있는 표현식이 반복될 횟수를 지정하는 숫자가 따라온다. 반복 구성요소 내부에 명령어를 넣어두는 방식은 각각 분리된 행으로 count 횟수만큼 명령어를 길게 늘여 표현하는 방식과 동일하다.

예를 들어, 반복 횟수가 다음과 같이 3이라고 하자.

.rept 3
     movl $2, %eax
.endr 

이는 다음과 같이 길게 늘여 표현하는 방식과 동일하다.

movl $2, %eax
movl $2, %eax
movl $2, %eax 

NASM에서는 선행처리 단계에서 비슷한 구성요소를 쓸 수 있다. %rep 지시자로 시작해 %endrep로 끝을 맺는다. (GAS에서는 .rept 지시자 뒤에 반복 회수가 따라나오는 반면에) 여기서는 %rep 지시자 뒤에 표현식이 따라온다.

%rep <ｅxpression>
     nop
%endrep 

NASM에서는 times 지시자라는 대용품도 존재한다. %rep와 비슷하게 times는 어셈블리 수준에서 동작하며, 역시 표현식이 뒤따라 나온다. 예를 들어 직전 %rep 구성요소는 다음과 대등하다.

times <ｅxpression> nop 

또한 다음 구성요소는

%rep 3
     mov eax, 2
%endrep 

다음과 동일하며, 

times 3 mov eax, 2 

둘 다 다음과 같이 길게 늘여 표현하는 방식과 동일하다.

mov eax, 2
mov eax, 2
mov eax, 2 

Listing 5에서 .rept(또는 %rep) 지시자는 더블 워드 10개를 위한 메모리 자료 영역을 만들어내기 위해 사용된다. 명령행 인수는 스택에서 하나씩 뽑아내어 접근하며, 명령 테이블이 가득 찰 때까지 차례로 메모리 영역에 저장된다.

명령행 인수는 양쪽 어셈블러에서 비슷하게 접근한다. ESP나 스택의 최상위에 프로그램에 제공할 명령행 인수 숫자가 들어 있으며, (명령행 인수가 없을 경우) 기본값은 1이다. esp + 4는 첫 번째 명령행 인수가 들어있는데, 항상 명령행에서 수행된 프로그램 이름이 된다. esp + 8, esp + 12 등은 이어지는 명령행 인수를 저장하고 있다.

Listing 5에서 양쪽 어셈블러가 메모리 명령어 테이블에 접근하는 방식을 유심히 살펴봐야 한다. 여기서 메모리 간접 주소지정 모드(33행)로 ESI (그리고 EDI)에 있는 변위와 승수를 사용해 명령어 테이블에 접근한다. 따라서 NASM에서 사용한 [cmd_tbl + esi * 4]는 GAS에서는 cmd_tbl(, %esi, 4)로 표현된다.


--------------------------------------------------------------------------------

위로

결론

두 어셈블러 사이에 차이점이 있지만, 한쪽에서 다른 쪽으로 변환하는 작업은 어렵지 않다. AT&T 구문은 처음에는 이해하기 힘들어 보일지 모르지만, 숙달되고 나면 인텔 구문만큼이나 단순함을 발견할 것이다.




참고자료

교육

두 어셈블러에 대한 완벽한 소개 내용을 담은 NASM과 GAS 매뉴얼을 참고한다. 
GAS: GNU 어셈블러 
NASM: 넷와이드 어셈블러 


위키백과에서 selection sort(선택 정렬)을 찾아 설명을 읽어본다.


developerWorks 리눅스 영역에서 리눅스 개발자를 위한 더 많은 참고 자료를 찾아보고 가장 인기 있는 기사와 튜토리얼을 검색하기 바란다. 


developerWorks에 게시된 모든 리눅스 팁과 리눅스 튜토리얼을 살펴본다. 


developerWorks 기술 행사와 웹 캐스트를 놓치지 말기 바란다. 


제품 및 기술 얻기

IBM 평가판 소프트웨어: developerWorks에서 직접 내려 받아 다음번 리눅스 프로젝트에 활용하자. 


토론

새로운 developerWorks spaces에 만들어진 블로그, 포럼, 포드캐스트, 공동체 토픽을 통해 developerWorks 공동체에 참여한다. 


필자소개

Ram은 전산학 석사를 마치고 IBM 인도 소프트웨어 연구소, Rational 부서에서 ClearCase 기능 추가 작업을 맡아 소프트웨어 엔지니어로 일하고 있다. Ram은 리눅스, 유닉스, 윈도우 운영체제와 심비안, 윈도우 모바일과 같은 실시간 모바일 기반 운영체제를 다룬다. 여가 시간에는 리눅스를 만지작거리며 책을 읽는다.

